
    public ConnectionResult ConnectNodesWithIntersect(Node node1, Node node2, float snapRadius, Node.ConnectionType type = Node.ConnectionType.Street) {
        Envelope bBox = Util.GetEnvelopeFromNodes(new List<Node>() { node1, node2 }, snapRadius);

        IEnumerable<Node> results = tree.Search(bBox);

        bool success = false;
        bool didSnap = false;
        bool didIntersect = false;
        Node prevNode = node1;
        List<IntersectionInfo> intersections = new List<IntersectionInfo>();

        List<Node> sortedRes = results
            .OrderBy(n => Vector3.Distance(node1.pos, n.pos))
            .ToList();

        Dictionary<Node, bool> added = new Dictionary<Node, bool>();

        foreach (Node other in sortedRes) {
            if (other == node1 || other == node2) continue;

            print("visited node " + other.pos);

            float dist = Util.GetMinimumDistanceToLine(
                Util.Vector3To2(other.pos),
                Util.Vector3To2(node1.pos),
                Util.Vector3To2(node2.pos)
            );
            if (dist < snapRadius) {
                success = this.ConnectNodesWithIntersect(node1, other, snapRadius, type).success;
                didSnap = true;
                node1 = other;
                prevNode = other;
                continue;
            }

            if (added.ContainsKey(other)) continue;
            added[other] = true;
            foreach (Node.NodeConnection connection in other.connections) {
                if (connection.node == node1) continue;
                if (added.ContainsKey(connection.node)) continue;
                added[connection.node] = true;

                Util.LineIntersection.Result intersection = Util.LineIntersection.CheckIntersection(
                    Util.Vector3To2(node2.pos),
                    Util.Vector3To2(node1.pos),
                    Util.Vector3To2(other.pos),
                    Util.Vector3To2(connection.node.pos)
                );

                if (intersection.type == Util.LineIntersection.Type.Intersecting) {
                    intersections.Add(new IntersectionInfo(other, connection, intersection));
                }
            }
        }

        if (!didSnap) {
            List<IntersectionInfo> sorted = intersections
                .OrderBy(n => Vector2.Distance(Util.Vector3To2(prevNode.pos), n.result.point))
                .ToList();

            foreach(IntersectionInfo info in sorted) {
                if (Vector2.Distance(Util.Vector3To2(info.from.pos), info.result.point) < snapRadius) {
                    success = this.ConnectNodes(node1, info.from, type);
                    this.ConnectNodes(info.from, node2, type);
                    didSnap = true;
                    break;
                }
                else if (Vector2.Distance(Util.Vector3To2(info.connection.node.pos), info.result.point) < snapRadius) {
                    success = this.ConnectNodes(node1, info.connection.node, type);
                    this.ConnectNodes(info.connection.node, node2, type);
                    didSnap = true;
                    break;
                }

                print("adding intersection node");
                Node n = AddNode(new Node(Util.Vector2To3(info.result.point), node1.type));

                DisconnectNodes(info.from, info.connection.node);
                ConnectNodes(info.from, n, info.connection.type);
                ConnectNodes(info.connection.node, n, info.connection.type);

                ConnectNodes(node1, n, type);

                if (Vector3.Distance(n.pos, node2.pos) < snapRadius) {
                    prevNode = n;
                    didSnap = true;
                }
                else {
                    ConnectNodes(n, node2, type);
                    prevNode = node2;
                }

                didIntersect = true;
                success = true;
            }
        }

        if (intersections.Count == 0) {
            print("no intersect");
            IEnumerable<Node> list = FindNodesInRadius(node2.pos, snapRadius);
            Node closestNode = Util.GetClosestNode(node2, list);
            if (closestNode != null) {
                print("found closest2");
                success = ConnectNodes(node1, closestNode, type);
                didSnap = true;
                return new ConnectionResult(success, didIntersect, didSnap, closestNode);
            }

            success = ConnectNodes(node1, node2, type);
            return new ConnectionResult(success, didIntersect, didSnap, node2);
        }

        return new ConnectionResult(success, didIntersect, didSnap, prevNode);
    }




    public ConnectionResult ConnectNodesWithIntersect(Node node1, Node node2, float snapRadius, Node.ConnectionType type = Node.ConnectionType.Street, bool direct = false) {
        if (Vector3.Distance(node1.pos, node2.pos) <= snapRadius) {
            return new ConnectionResult(false, false, true, node1);
        }

        // Create bounding envelope containing both nodes, including some snapRadius margin
        Envelope bBox = Util.GetEnvelopeFromNodes(new List<Node>() { node1, node2 }, snapRadius);

        IEnumerable<Node> results = tree.Search(bBox);

        // Sort by closest nodes
        List<Node> sortedRes = results
            .OrderBy(n => Vector3.Distance(node1.pos, n.pos))
            .ToList();

        List<IntersectionInfo> intersections = new List<IntersectionInfo>();

        Dictionary<Node, bool> added = new Dictionary<Node, bool>();
        bool success = false;
        foreach (Node other in sortedRes) {
            if (other == node1 || other == node2) continue;

            // First, check if the node is within snapRadius of the destination node
            // If so, snap to it
            if (Vector3.Distance(other.pos, node2.pos) <= snapRadius && !direct) {
                ConnectionResult res = ConnectNodesWithIntersect(node1, other, snapRadius, type, true);

                print("DEBUG");
                debugPoints.Add(other.pos);

                return new ConnectionResult(false, res.didIntersect, res.didSnap, res.prevNode);
            }

            // Check nodes along the desired connection line
            // If found, snap to that node
            if (!direct){
                float dist = Util.GetMinimumDistanceToLine(
                    Util.Vector3To2(other.pos),
                    Util.Vector3To2(node1.pos),
                    Util.Vector3To2(node2.pos)
                );
                if (dist <= snapRadius && Vector3.Distance(other.pos, node1.pos) > snapRadius) {
                    ConnectionResult res = ConnectNodesWithIntersect(node1, other, snapRadius, type, true);

                    return new ConnectionResult(false, res.didIntersect, res.didSnap, res.prevNode);
                }
            }

            // This is to ensure intersection test is not performed on the same connection twice
            // This is due to nodes having bi-directional connections
            if (added.ContainsKey(other)) continue;
            added[other] = true;

            foreach (Node.NodeConnection connection in other.connections) {
                if (connection.node == node1 || connection.node == node2) continue;

                // Perform a ray-line intersection test
                // This results in three scenarios:
                // 1. No intersection and no snapping should be done.
                // 2. The new connection line is intersecting with another connection, create intersection
                // 3. The new connection line is almost intersecting with another connection (it is within snapRadius),
                //    "extend" the new connection line so that it intersects with the existing connection
                Util.LineIntersection.Result intersection = Util.LineIntersection.RayTest(
                    Util.Vector3To2(other.pos),
                    Util.Vector3To2(connection.node.pos),
                    Util.Vector3To2(node1.pos),
                    Util.Vector3To2(node2.pos - node1.pos)
                );

                bool didIntersect = false;
                if (intersection.type == Util.LineIntersection.Type.Intersecting) {
                    // Scenario #2
                    if (intersection.factorB <= 1) {
                        intersections.Add(new IntersectionInfo(other, connection, intersection.point));
                        didIntersect = true;
                    }
                    // Scenario #3
                    else if (!direct) {
                        float distLine = Vector2.Distance(Util.Vector3To2(node2.pos), intersection.point);
                        if (distLine <= snapRadius) {
                            // The ray intersection handles the extension for us, so simply add this result
                            intersections.Add(new IntersectionInfo(other, connection, intersection.point));
                            didIntersect = true;
                        }
                    }
                }

                if (!didIntersect && !direct) {
                    Vector2 proj = Util.GetProjectedPointOnLine(
                        Util.Vector3To2(node2.pos),
                        Util.Vector3To2(other.pos),
                        Util.Vector3To2(connection.node.pos)
                    );

                    float distProj = Vector2.Distance(proj, Util.Vector3To2(node2.pos));
                    if (distProj <= snapRadius) {
                        intersections.Add(new IntersectionInfo(other, connection, proj));
                    }
                }
            }
        }

        // Resolve potential intersections
        if (intersections.Count > 0) {
            // Multiple intersections can occur, make sure we take the closest one
            List<IntersectionInfo> sorted = intersections
                .OrderBy(n => Vector2.Distance(Util.Vector3To2(node1.pos), n.point))
                .ToList();

            // TODO: This does not need to be a for loop, since all it needs is the first element
            foreach(IntersectionInfo info in sorted) {
                Node n = AddNode(new Node(Util.Vector2To3(info.point), node1.type));

                // Split the connection to include the new intersection node
                DisconnectNodes(info.from, info.connection.node);
                ConnectNodes(info.from, n, info.connection.type);
                ConnectNodes(info.connection.node, n, info.connection.type);

                // Connect the origin node to the new intersection node
                ConnectNodes(node1, n, type);

                return new ConnectionResult(false, true, false, n);
            }
        }

        // If no intersections or no snapping are found, just connect the desired nodes
        success = ConnectNodes(node1, node2, type);

        return new ConnectionResult(success, false, false, node2);
    }
